# Linux文件系统

Linux的文件系统由两个部分构成：VFS层和各种文件系统的实现。

VFS层屏蔽了下层各种文件系统之间的区别，为上层的应用程序提供统一的访问接口。而各种各样的文件系统实现则将继承自Unix的 __一切皆文件__ 的理念变为现实。

## VFS的架构

VFS为各种文件系统提供了一组核心的通用抽象，包括：

* `struct super_block`

  __文件系统元数据的抽象__
  
  `struct super_block`是VFS为文件系统提供的抽象，它包含了一个文件系统所应当具有的所有元数据，例如块大小、空闲块数量、允许的最大文件大小等。除此之外，作为文件系统元数据的运行时表示，`struct super_block`还提供了对`struct inode`和`struct file`的管理功能，用于快速寻找属于某一文件系统的所有`inode`和`file`以及将脏的`inode`写回相应的存储介质。

  `struct super_block`中类型为`struct super_operations *`的`s_op`成员指向的结构体中保存了底层文件系统实现的对文件系统的各种操作的函数指针。主要包括存储介质的挂载与卸载、存储介质上空间的分配与回收（表现为`inode`的分配与回收），文件元数据的读写（表现为`inode`的读写），存储介质与内存之间的数据同步（写回机制）以及文件系统的状态获取与配置。

  操作系统会为每一个活跃的存储器分区维护一个`struct super_block`实例。

* `struct inode`

  __文件元数据的抽象__

  `struct inode`是VFS提供的对文件元数据的统一抽象，它包含了一个文件应有的元数据，包括文件大小、文件权限、文件所有者、最后访问时间等。`struct super_operations`中的`read_inode`函数用于从存储介质上读取文件的元数据并填充到给定的`struct inode`实例中。

  与`struct super_block`与`struct super_operations`的关系类似，`struct inode`也有一个类型为`struct inode_operations *`的成员`i_op`。它指向的结构体中保存了底层文件系统实现的用于操作文件元数据的函数指针，包括文件的创建、删除、重命名，文件大小调整，文件权限检查，链接的创建与删除以及底层文件系统自定义的文件元数据的操作等。

* `struct file`
  
  __文件内容的抽象__
  
  `struct file`是VFS提供的对于文件内容的抽象，也是应用程序能够操作的文件的表示。`struct file`包含了应用程序对文件进行读写操作时所需要的信息，包括文件所有者、文件打开方式、文件读写指针位置等。
  
  当用户使用标准库的`open`或`openat`函数打开未曾打开过的文件时，将会在程序的打开文件表中添加一个指向打开的文件的指针，并将该文件在打开文件表中的索引，即文件描述符返回给应用程序，随后应用程序可通过文件描述符来对文件进行操作。

  `struct file`同样拥有一个`struct file_operations`结构体指针成员`f_op`，保存了底层文件系统实现的文件操作函数的指针。包括通用的读写操作函数，用于可随机读写文件的seek函数，用于设备文件的控制函数等。

在这些核心抽象的基础上，VFS还提供了一系列的对象和函数用于简化文件系统管理、简化文件系统实现、提升文件系统性能等，包括：

* `struct file_system_type`
  
  __用于管理内核已知的文件系统__

  Linux系统中往往同时存在着多个文件系统，而`struct file_system_type`就是用来管理这些文件系统的数据结构。对于每一个文件系统实现，内核会维护一个对应的`struct file_system_type`实例，它包含了两个重要函数的指针：

  + `get_sb`：从存储介质中读取信息填充给定的`struct super_block`实例
  
  + `kill_sb`：释放不再使用的`struct super_block`实例，这通常发生在卸载存储设备时

  以及属于该文件系统的的所有`struct super_block`实例链表头`fs_supers`。

* `struct vfsmount`
  
  __用于表示设备挂载点__

  `struct vfsmount`用于表示设备挂载点，其中记录了设备挂载的父文件系统的挂载点、设备自身的挂载点、设备的根目录、设备的`struct super_block`实例指针等信息。

* `struct dentry`
  
  __文件目录项缓存__

  文件目录树的节点，用于保存文件目录项的信息，包括文件名、相应的`inode`等。`dentry`最重要的作用是作为文件系统的缓存，加速文件的查找。

  每当VFS和文件系统实现找到一个目录项之后，就会使用它的名称以及相应的`inode`等创建一个`dentry`实例缓存起来，这样当下一次需要查找同一个文件时，就可以省去访问外存的开销。

  `dentry`同样支持文件系统实现自定义的操作，包括有效性验证、获取散列值、比较、释放、删除等。

* `struct address_space`
  
  __实现内存映射__

* `struct file_lock`
  
  __用于线程同步__

## VFS的实现

### 注册文件系统
  
  文件系统可以以模块形式或直接编译进内核的形式添加到系统中，文件系统自身需要调用内核提供的`register_filesystem`函数来完成注册，该函数将文件系统对应的`struct file_system_type`实例添加到已注册文件系统链表中。

### 文件系统的挂载和卸载
  
文件系统挂载通过`mount`系统调用实现，`sys_mount`是`mount`系统调用的底层实现，但是`sys_mount`本身仅仅只是将挂载参数由用户空间复制到内核空间，随后就将控制权交给了`do_mount`，真正的挂载操作由`do_mount`指派给各个负责不同类型挂载的函数完成。

要挂载一个文件系统，首先需要获取文件系统相关的元数据，这些工作包括：

* 根据挂载点路径找到相应的`struct dentry`项和`struct vfsmount`项；

* 根据文件系统名称在已加载文件系统实现中查找相应实现，若找不到则尝试载入相应的模块，最终得到相应的`struct file_system_type`实例；

* 使用`struct file_system_type`实例中的`get_sb`函数从设备文件中读入文件系统元数据，构造`struct super_block`实例，并填充相应的`struct vfsmount`实例；

至此，文件系统元数据的读取和构造就完成了，接下来需要处理新文件系统与父文件系统的关联，包括：

* 将新文件系统的`struct vfsmount`实例的`mnt_parent`成员指向挂载点所在文件系统的`struct vfsmount`实例，`mnt_mountpoint`成员指向挂载点对应的`struct dentry`项；

* 将新文件系统的`struct vfsmount`实例添加到全局散列表，以及父文件系统`struct vfsmount`实例中的子文件系统链表；

文件系统的卸载总体上是挂载的逆过程，不再赘述。

### 文件操作
  
* 查找inode

  操作文件的第一步是根据给定的文件路径打开找到或读入相应的inode信息。这主要包括如下步骤：

  + 检查文件路径是否以`/`开头，若是则从根目录开始查找，否则从当前进程的当前工作目录开始查找；
  
  + 对于每一个路径分量，需要检查
  
    - 当前进程是否有访问权限；
    
    - 是否是特殊文件名如`.`和`..`，若是，需要特殊处理；
    
    - 是否是符号链接，若是，需要特殊处理；
    
    - 是否是挂载点，若是，需要执行相应的切换；
  
  + 检查完成之后，根据文件名查找相应的`struct dentry`实例。首先会尝试在缓存中查找，若找到，对缓存项进行验证，验证通过则当前路径分量查找成功；若在缓存中找不到或验证失败，则调用底层文件系统实现的查找函数（`struct dentry_operations`中的`lookup`函数）获得`struct dentry`项。
  
  + 若最终查找到的项是一个符号链接，则还需要跟踪该符号链接找到最终指向的文件，此过程需要限制符号链接的递归深度，避免循环链接导致的死循环；
